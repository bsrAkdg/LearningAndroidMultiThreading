
** Instantiating New Threads : Two way
    ** Instantiated thread != started thread (you should call start())

    1. Create a class : (Inheritance)
        public class MyThread extends Thread {
            private final int mSeed;

            public MyThread(int seed) {
                mSeed = seed;
            }

            @Override
            public void run() {
                // perform some calculation
            }
        }

        Thread myCustomThread = new MyThread(10);
        myCustomThread.start(); // start thread

    2. User runnable : (Composition) This is a container for threads

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                int seed = 10;
                // perform some calculation
            }
        }

        Thread thread = new Thread(runnable);
        thread.start(); // start thread

** Effective Java Item 18 : Favor Composition over Inheritance

** Important roots in Android application : (do not eligible GC)
    1. Objects referenced from static fields
    2. Instances of Application class* (custom subclass of application class)
    3. Live threads (thread.start())

        - Anonymous Threads : MainActivity instance can't be GC'ed as long as the anonymous Thread instance is live
            public class MainActivity ... {
                @Override
                protected void onCreate(){
                    new Thread(new Runnable() {
                        @Override
                        public void run() {
                            // perform some long-running operation
                        }
                    }).start();
                }
            }
        - Inner Threads : MainActivity instance can't be GC'ed as long as the anonymous Thread instance is live

            public class MainActivity ... {
                @Override
                protected void onCreate(){
                    new MyThread().start();
                }

                private class MyThread extends Thread {
                    @Override
                    public void run() {
                        // perform some long-running operation
                    }
                }
            }

** Thread Termination Strategies

    1. Return from run() after successful execution :
    -------------------------------------------------
    Normally anonymous threads don't eligible GC,
    but anonymous Thread can access Activity's fields because it has implicit reference to the enclosing
    object.

        public class MainActivity ... {

            private EndPoint endPoint;
            private ItemsDao itemsDao;

            @Override
            protected void onCreate(){
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        List<Item> items = endPoint.fetch();
                        itemsDao.insertItems(items);
                    }
                }).start();
            }
        }

    2. Return from run() in response to internal error :
    ----------------------------------------------------
    When you return in an error there is no problem for memory leak.

         public class MainActivity ... {

            private EndPoint endPoint;
            private ItemsDao itemsDao;

            @Override
            protected void onCreate(){
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        List<Item> items;

                        try {
                            items = endPoint.fetch();
                        } catch (IOException e) {
                            return; // it's important!!
                        }
                        itemsDao.insertItems(items);
                    }
                }).start();
            }
         }

    3. Return from run() in response to externally set flag
    -------------------------------------------------------
    If the flag is changed after execution passed the condition that checks it, this will have no effect

         public class MainActivity ... {

            private EndPoint endPoint;
            private ItemsDao itemsDao;
            private AtomicBoolean fetchAborted = new AtomicBoolean(false); // it's a flag

            @Override
            protected void onCreate(){
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        List<Item> items = endPoint.fetch();
                        if (fetchAborted.get()) { // it's important!!
                            return;
                        }
                        itemsDao.insertItems(items);
                    }
                }).start();
            }
         }

    4. Return from run() in response to interruption
    ------------------------------------------------
    To interrupt a thread from outside, we need to have a reference to it.
    Thread interruption might look like externally set flag, but it's much more nuanced and complex mechanism.
    Favor externally set flag over thread interruption.

         public class MainActivity ... {

            private EndPoint endPoint;
            private ItemsDao itemsDao;
            private Thread thread;

            @Override
            protected void onCreate(){
                thread = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        List<Item> items = endPoint.fetch();
                        if (Thread.interrupted()) { // it's important!!
                            return;
                        }
                        itemsDao.insertItems(items);
                    }
                });
                thread.start();
            }
         }

** UI Thread Characteristics
    1. Started by Android Framework when application starts
    2. Terminated only when application's process terminates
    3. Application's user interface is "drawn" on UI thread
    4. Lifecycle callbacks (e.g onStart(), onStop()) are executed on UI thread
    5. User interaction event handlers are executed on UI thread
    6. Changes of user interface must be performed on UI thread

** UI Responsiveness Requirements :

   Android application should render 60 frames per seconds (FPS)
                            ||
                          \ || /
                            \/
   New frame each 16 milliseconds
                            ||
                          \ || /
                            \/
   Your code shouldn't execute on UI thread for longer than few milliseconds

** UI Responsiveness Warning Signs :

   1. Freezes of user interface, non-smooth animations, etc.
   2. Notifications about skipped frames in logcat :
        I/Choreographer : Skipped 611 frames! The application may be doing too much work on its main thread.
        611 frames * 16 ms = 10 seconds (too much work on UI thread)
   3. Crashes due to Application Not Responding (ANR) error

** Zero skipped frames in one of the fundamental quality standards of Android applications (can be relaxed for lowest-end devices)
** All time consuming operations should be offloaded to background threads
